Voy a darte contexto de que trata este proyecto para que optimices lo m치ximo posibles las respuestas de las consultas sin desviarte.

Con este proyecto estoy tratando de implementar una soluci칩n IoT utilizando The Things Network (TTN) en su versi칩n sandbox gratuita. Utilizando el protocolo de comunicaci칩n LoRaWan
He configurado un dispositivo IoT (Arduino WAN) que debe gestionar la comunicaci칩n bidireccional entre sensores f칤sicos y una aplicaci칩n web (el proyecto que estamos tratando).
El sistema IoT en s칤 tiene por objetivo la automatizaci칩n de riegos de cultivos. Por ello se ha creado un SPA que permita a los usuarios registrados gestionar el riego de sus cultivos. En funci칩n de los valores de humedad y temperatura. Adem치s desde la aplicaci칩n se podr치 tener un control sobre la bomba por lo que la aplicaci칩n web tambi칠n va a enviar informaci칩n a la red IoT con el objetivo de que el dispostivo IoT controle el actuador de la bomba.

Esta aplicaci칩n web se va a encargar de gestionar los dispostivos registrados por el usuario, a침adir y seleccionar cultivos a regar (1 cultivo por usuario, es decir se selecciona un cultivo y ya no se pueden seleccionar m치s) etc...

El proyecto esta debidido en 3 partes, una es edge computing, fog computing y cloud computing. Edge computing se refiere directamente al procesamiento que se desarrolla en el microcontrolador al que est치n conectado los sensores en este caso el microcontrolador con el sensor dht11 y capacitive soil moisture v1.2. Fog computing act칰a como una capa intermedia entre cloud y edge. Permite procesar y filtrar datos. En relaci칩n a nuestro proyecto el actor principal en la capa de Fog computing ser칤a el gateway, que se encarga de filtrar los datos proveniente del microcontrolador hacia el servidor de red de TTN. Por 칰ltimo tenemos cloud computing cuyos actores principales ser칤a el servidor de red de ttn y la base de datos de nuestra aplicaci칩n.

Otro factor importante es la manera en la que se va  dar la comunicaci칩n entre el dispositivo microcontrolador y la red TTN, la comunicaci칩n se dar치 en 2 direcciones: uplink y downlink. Vamos a enfocarnos en describir el uplink.

1. Se captan datos de los sensores y se procesan en el microcontrolador
2. El microcontrolador env칤a los datos de temperatura y humedad al servidor de red a trav칠s del gateway que act칰a como puente entre microcontrolador y servidor de red TTN
3. Desde el servidor de mi aplicaci칩n hago una consulta al endpoint HTTP que he definido en el webhook de TTN. El webhook va a enviar los datos recibidos por TTN al endpoint HTTP ya configurado por m칤 previamente. Cuando un dispositivo LoRaWAN transmite un mensaje (por ejemplo, temperatura, humedad, estado de la bomba...), TTN lo recibe y reenv칤a autom치ticamente ese mensaje a tu servidor web o API (por ejemplo, tu index.ts en Node.js).
4. Despu칠s de hacer la consulta la api devuelve una respuesta json con los datos de humedad y temperatura y tambi칠n las credenciales del dispositivo que las esta enviando, para luego almacenarlo en la base de datos. De esta manera los datos enviandos por el microcontrolador de los sensores quedar치n registrados en la base de datos y disponibles en la aplicaci칩n web.

Ahora vamos a describir como funciona el downlink


1. Petici칩n de acci칩n desde la interfaz web
El usuario interact칰a con la aplicaci칩n web (por ejemplo, presionando un bot칩n "ON" o "OFF" en el dashboard).
游대 Esta acci칩n desencadena una llamada HTTP (POST) al backend que est치s ejecutando con Express.

2. El backend llama a la API de TTN para encolar un downlink
El servidor Node.js toma esta solicitud y prepara un paquete JSON con:

frm_payload: el comando codificado en base64 (por ejemplo, AQ== para 0x01)

f_port: el puerto l칩gico (normalmente 1)

priority: la prioridad del downlink (NORMAL o HIGH)

confirmed: si se espera confirmaci칩n del nodo

游닋 Esta estructura se env칤a mediante POST a la URL:

https://<region>.cloud.thethings.network/api/v3/as/applications/<app_id>/devices/<dev_eui>/down/push
游릭 Si la petici칩n tiene 칠xito, TTN a침ade el paquete a una cola de downlinks espec칤fica del dispositivo.

3. TTN espera el pr칩ximo uplink para entregar el downlink
Aqu칤 ocurre lo interesante:

Los dispositivos LoRaWAN clase A, como el Arduino MKR WAN 1310, solo pueden recibir downlinks justo despu칠s de enviar un uplink.

Entonces TTN guarda el downlink en cola hasta que el nodo env칤e un uplink (por ejemplo, datos de sensores o un paquete vac칤o).

4. El nodo env칤a un uplink (sensor, dummy, heartbeat, etc.)
Cuando el nodo transmite un uplink (autom치tico o provocado), se abren dos ventanas de recepci칩n:

RX1 (~1 segundo despu칠s del uplink)

RX2 (~2 segundos despu칠s, con par치metros predefinidos)

Es durante esas ventanas cuando TTN entrega el downlink que estaba encolado.

5. El microcontrolador recibe el downlink y act칰a
Dentro del c칩digo del microcontrolador:

Se detecta que hay un downlink (modem.available())

Se lee el byte recibido (por ejemplo, 0x01 para "ON")

El sistema act칰a en consecuencia: encender la bomba, cambiar un LED, etc.

Opcionalmente, el micro puede responder con un uplink de confirmaci칩n.



El objetivo de este proyecto es automatizar el riego con el fin de ahorrar la m치xima cantidad de agua posible y mantener un control exhaustivo del riego. De ah칤 que existan 3 modos de operaci칩n manual, programado y autom치tico

